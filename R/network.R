# file checked
#' @name network
#' @title generate haplotype net relationshop with haplotype result
#' @description computes a haplotype network with haplotype summary result
#' @seealso
#' \code{\link[geneHapR:plotHapNet]{plotHapNet()}} and
#' \code{\link[geneHapR:hap_summary]{hap_summary()}}.
#' @usage
#' get_hapNet(hapSummary,
#'            accGroup = accGroup,
#'            groupName = groupName)
#' @inherit plotHapNet examples
#' @importFrom pegas haploNet
#' @importFrom stringdist stringdist
#' @references
#'
#' Article{,
#' title = {The stringdist package for approximate string matching},
#' author = {M.P.J. {van der Loo}},
#' year = {2014},
#' journal = {The {R} {J}ournal},
#' volume = {6},
#' issue = {1},
#' url = {https://CRAN.R-project.org/package=stringdist},
#' pages = {111-122},
#' }
#' Article{,
#'     title = {pegas: an {R} package for population genetics with an integrated--modular approach},
#'     author = {E. Paradis},
#'     journal = {Bioinformatics},
#'     year = {2010},
#'     volume = {26},
#'     pages = {419-420},
#' }
#' @param hapSummary object of `hapSummary` class, generated by `hap_summary()`
#' @param accGroup data.frame, specified groups of each accession.
#' Used for pie plot. If missing, pie will not draw in plotHapNet.
#' Or you can supplied a hap_group mattrix with `plot(hapNet, pie = hap_group)`.
#' @param groupName the group name used for pie plot,
#' should be in `accGroup` column names, default as the first column name
#' @return haplonet class
#' @export
get_hapNet <-
    function(hapSummary,
             accGroup = accGroup,
             groupName = groupName) {
        if (!inherits(hapSummary, "hapSummary"))
            stop("'hapSummary' should be of 'hapSummary' class")
        d <- getStringDist(hapSummary)
        hapNet <- pegas::haploNet(as.haplotype(hapSummary), d)
        if (!missing(accGroup)) {
            if (missing(groupName))
                groupName <- colnames(accGroup)[1]
            hapGroup <- getHapGroup(hapSummary,
                                    accGroup = accGroup,
                                    groupName = groupName)
            attr(hapNet, "hapGroup") <- hapGroup
        }
        return(hapNet)
    }


#' @name plotHapNet
#' @title plotHapNet
#' @importFrom graphics legend
#' @usage
#' plotHapNet(hapNet,
#'            size = "freq", scale = TRUE, scale.ratio = 1, cex = 0.8,
#'            col.link = 1, link.width = 1,
#'            show.mutation = 1,
#'            backGround = backGround, hapGroup = hapGroup,
#'            addLegend = TRUE,
#'            legendPosition = "left", ...)
#' @param hapNet an object of class "haploNet"
#' @param size a numeric vector giving the diameter of the circles
#'  representing the haplotypes: this is in the same unit than the
#'  links and eventually recycled.
#' @param scale.ratio the ratio of the scale of the links representing
#'  number of steps on the scale of the circles representing the haplotypes.
#'  It may be needed to give a value greater than one to avoid overlapping
#'  circles.
#' @param col.link a character vector specifying the colours of the links;
#' eventually recycled.
#' @param link.width a numeric vector giving the width of the links;
#' eventually recycled.
#' @param show.mutation an integer value:
#'
#' if 0, nothing is drawn on the links;
#'
#' if 1, the mutations are shown with small segments on the links;
#'
#' if 2, they are shown with small dots;
#'
#' if 3, the number of mutations are printed on the links.
#' @param backGround a color vector with length equal to number of
#' Accession types
#' @param hapGroup a matrix used to draw pie charts for each haplotype;
#' its number of rows must be equal to the number of haplotypes
#' @param addLegend a logical specifying whether to draw the legend,
#' default as `TRUE`
#' @param cex character expansion factor relative to current par("cex")
#' Used for text, and provides the default for pt.cex.
#' @param scale bool type indicate whether scale the circle size
#' with 'log10(size + 1)', default as `TRUE`
#' @param legendPosition indicate where to plot the legend.
#' Should be one of "bottomright", "bottom", "bottomleft", "left", "topleft",
#' "top", "topright", "right", "center"
#' @param ... other parameters will pass to `plot` function
#' @seealso
#' \code{\link[geneHapR:hap_summary]{hap_summary()}} and
#' \code{\link[geneHapR:get_hapNet]{get_hapNet()}}.
#' @examples
#'
#' # load sample datasets
#' data("geneHap_test")
#'
#' # generate haplotype result from vcfR
#' hap <- vcf2hap(vcf)
#' hapSummary <- hap_summary(hap)
#'
#' # calculate haploNet
#' hapNet <- get_hapNet(hapSummary,
#'                      accGroup = accGroup, # accession types
#'                      groupName = colnames(accGroup)[2])
#'
#' # plot haploNet
#' plot(hapNet)

#' # plot haploNet
#' plotHapNet(hapNet,
#'            size = "freq", scale.ratio = 1,  # circle size
#'            scale = TRUE, # scale circle with 'log10(size + 1)'
#'            cex = 1, # size of hap symbol
#'            col.link = 2, # link colors
#'            link.width = 2, # link widths
#'            show.mutation = 2, # mutation types one of c(0,1,2,3)
#'            legendPosition = "right") # legend position
#' @export
plotHapNet <- function(hapNet,
                       size = "freq",
                       scale = TRUE,
                       scale.ratio = 1,
                       cex = 0.8,
                       col.link = 1,
                       link.width = 1,
                       show.mutation = 1,
                       backGround = backGround,
                       hapGroup = hapGroup,
                       addLegend = TRUE,
                       legendPosition = "left",
                       ...) {
    if (!inherits(hapNet, "haploNet"))
        stop("'hapNet' must be of 'haploNet' class")

    if (missing(hapGroup))
        hapGroup <- attr(hapNet, "hapGroup")


    if (size == "freq")
        size <- attr(hapNet, "freq")
    else
        if (!is.numeric(size))
            stop("'size' should be 'freq' or a given vector")

    if (scale)
        size <- (log10(size + 1) * 10) %/% 1


    if (!is.null(hapGroup)) {
        if (missing(backGround))
            backGround <- rainbow(ncol(hapGroup))

        plot(
            hapNet,
            col.link = col.link,
            threshold = 10,
            size = size,
            scale.ratio = scale.ratio,
            cex = cex,
            show.mutation = show.mutation,
            lwd = link.width,
            bg = backGround,
            pie = hapGroup
        )

        if (addLegend)
            legend(
                x = legendPosition,
                legend = colnames(hapGroup),
                fill = backGround,
                cex = 0.6,
                ...
            )
    } else {
        if (missing(backGround))
            backGround <- "grey90"

        plot(
            hapNet,
            col.link = col.link,
            bg = backGround,
            size = size,
            scale.ratio = scale.ratio,
            cex = cex,
            show.mutation = show.mutation,
            lwd = link.width,
            # legend = addLegend,
            ...
        )
    }
}



#' @name ashaplotype
#' @title as.haplotype
#' @usage
#' as.haplotype(hap)
#' @description convert `hapSummary` or `hapResult` class into `haplotype` class (pegas)
#' @note It's not advised for `hapSummary` or `hapResult` with indels, due to indels will
#' convert to SNPs with equal length of each indel.
#' @importFrom ape as.DNAbin
#' @param hap object of `hapSummary` or `hapResult` class
#' @return haplotype class
#' @export
as.haplotype <- function(hap) {
    if (!inherits(hap, "hapSummary"))
        stop("'hapSummary' must be of 'hapSummary' class")
    # get freq
    freq <- hap$freq
    names(freq) <- hap$Hap
    freq <- freq[!is.na(freq)]

    # get hap mattrix
    hapDNAset <- hap2string(hap = hap, type = "DNA")
    hapBin <- ape::as.DNAbin(hapDNAset)
    hapmatt <- unlist(as.character(as.matrix(hapBin)))

    # set as haplotype
    class(hapmatt) <- c("haplotype", "character")
    rownames(hapmatt) <- names(freq)
    N <- nrow(hapmatt)
    attr(hapmatt, "index") <-
        lapply(1:N, function(i)
            seq_len(freq[i]))
    return(hapmatt)
}


#' @importFrom stringr str_detect str_pad str_length
#' @importFrom Biostrings DNAStringSet
hap2string <- function(hap, type = "DNA") {
    colNms <- colnames(hap)
    if ("Accession" %in% colNms)
        hap <- hap[, colnames(hap) != 'Accession']
    if ("freq" %in% colNms)
        hap <- hap[, colnames(hap) != 'freq']
    if (nrow(hap) <= 5)
        stop("There is only one Hap ?")
    meta <- hap[1:4, ]
    hap <- hap[5:nrow(hap), ]
    ALLELE <- meta[meta[, 1] == "ALLELE", ]

    # padding multiallelic indel sites
    if (type == "DNA") {
        multi_probe <- is.indel.allele(ALLELE)
        for (c in seq_len(ncol(hap))) {
            if (multi_probe[c]) {
                if (stringr::str_sub(ALLELE[c], 2, 2) == "/")
                    side = "right"
                else
                    side = "left"
                maxLen <- max(stringr::str_length(hap[, c]))
                hap[, c] <- stringr::str_pad(hap[, c],
                                             width = maxLen,
                                             side = side,
                                             pad = "-")
            }
        }

        # conneting strings
        DNASeqs <- sapply(seq_len(nrow(hap)),
                          function(i)
                              paste0(hap[i, -1], collapse = ""))
        names(DNASeqs) <- hap$Hap
        hapString <-
            Biostrings::DNAStringSet(DNASeqs, use.names = T, start = 1)
    } else {
        for (c in 2:ncol(hap)) {
            ALc <- ALLELE[c]
            ALs <- unlist(stringr::str_split(ALc, "[,/]"))
            ALn <- LETTERS[seq_len(length(ALs))]
            names(ALn) <- ALs
            hap[, c] <- ALn[hap[, c]]
        }

        hapString <- sapply(seq_len(nrow(hap)),
                            function(i)
                                paste0(hap[i, -1], collapse = ""))
        names(hapString) <- hap$Hap
    }



    return(hapString)
}



#' @importFrom stringdist stringdist
getStringDist <- function(hapSummary) {
    hapStrings <- hap2string(hapSummary, type = "LETTER")
    n <- names(hapStrings)
    l <- length(hapStrings)
    d <- matrix(nrow = l,
                ncol = l,
                dimnames = list(n, n))
    for (i in seq_len(length(hapStrings))) {
        for (j in seq_len(length(hapStrings))) {
            d[i, j] <- stringdist::stringdist(hapStrings[i],
                                              hapStrings[j],
                                              method = "lv")
        }
    }
    d <- d[lower.tri(d)]
    attr(d, "Size") <- l
    attr(d, "Labels") <- n
    attr(d, "method") <- "lv"
    attr(d, "Diag") <- attr(d, "Upper") <- FALSE
    class(d) <- "dist"
    return(d)
}


getHapGroup <- function(hap,
                        accGroup = accGroup,
                        groupName = groupName) {
    # get indvidual group number of each hap
    hap2acc <- attr(hap, "hap2acc")
    acc2hap <- names(hap2acc)
    names(acc2hap) <- hap2acc
    accGroup$Hap <- acc2hap[rownames(accGroup)]
    with(accGroup[, c("Hap", groupName)],
         table(hap = accGroup$Hap, group = accGroup[, groupName]))
}
